# 盲道检测系统 - 代码规范

## 概述

本文档定义了盲道检测系统的代码规范和开发标准，确保团队成员能够编写一致、可维护的代码。

## Python代码规范

### 1. 基本规范

#### 1.1 代码风格
- 遵循 **PEP 8** 规范
- 使用 **4个空格** 进行缩进，不使用Tab
- 行长度不超过 **120字符**
- 使用 **UTF-8** 编码

#### 1.2 命名规范

**变量和函数命名：**
```python
# 使用snake_case
user_name = "张三"
detection_result = detect_blind_path(image)

# 常量使用UPPER_CASE
MAX_DETECTION_CONFIDENCE = 0.8
DEFAULT_MODEL_PATH = "models/yolov8n.pt"
```

**类命名：**
```python
# 使用PascalCase
class BlindRoadDetector:
    pass

class VoiceNavigator:
    pass

class ModuleCommunicator:
    pass
```

**模块和包命名：**
```python
# 使用snake_case
import blind_road_sdk
import voice_navigator
import module_communication
```

### 2. 文件结构规范

#### 2.1 文件头部
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
文件描述
详细说明文件的功能和用途
"""

import os
import sys
from typing import Dict, List, Optional
```

#### 2.2 导入顺序
```python
# 1. 标准库导入
import os
import sys
import json

# 2. 第三方库导入
import cv2
import numpy as np
import torch

# 3. 本地模块导入
from core.blind_road_sdk import BlindRoadDetector
from voice_system.voice_navigator import VoiceNavigator
```

### 3. 函数和类规范

#### 3.1 函数定义
```python
def detect_blind_path(
    image: np.ndarray,
    confidence_threshold: float = 0.5,
    model_path: str = "models/yolov8n.pt"
) -> Dict[str, Any]:
    """
    检测图像中的盲道
    
    Args:
        image: 输入图像数组
        confidence_threshold: 置信度阈值
        model_path: 模型文件路径
    
    Returns:
        检测结果字典，包含检测框、置信度等信息
    
    Raises:
        ValueError: 当输入图像无效时
        FileNotFoundError: 当模型文件不存在时
    """
    pass
```

#### 3.2 类定义
```python
class BlindRoadDetector:
    """盲道检测器类
    
    提供盲道检测的核心功能，包括图像预处理、
    模型推理和结果后处理。
    """
    
    def __init__(self, model_path: str = "models/yolov8n.pt"):
        """初始化检测器
        
        Args:
            model_path: 模型文件路径
        """
        self.model_path = model_path
        self.model = None
        self._load_model()
    
    def detect(self, image: np.ndarray) -> Dict[str, Any]:
        """执行盲道检测
        
        Args:
            image: 输入图像
            
        Returns:
            检测结果
        """
        pass
```

### 4. 注释规范

#### 4.1 文档字符串
```python
def process_detection_result(result: Dict[str, Any]) -> str:
    """处理检测结果并生成语音指令
    
    根据检测结果中的障碍物类型和位置信息，
    生成相应的语音导航指令。
    
    Args:
        result: 检测结果字典，包含以下键：
            - 'has_obstacle': bool, 是否有障碍物
            - 'obstacle_type': str, 障碍物类型
            - 'confidence': float, 检测置信度
            - 'bbox': List[int], 边界框坐标
    
    Returns:
        生成的语音指令字符串
        
    Example:
        >>> result = {
        ...     'has_obstacle': True,
        ...     'obstacle_type': '石头',
        ...     'confidence': 0.8
        ... }
        >>> instruction = process_detection_result(result)
        >>> print(instruction)
        "前方发现石头，请注意安全"
    """
    pass
```

#### 4.2 行内注释
```python
# 加载预训练模型
model = torch.load(model_path)

# 图像预处理：调整尺寸和归一化
processed_image = cv2.resize(image, (640, 640))
processed_image = processed_image.astype(np.float32) / 255.0

# TODO: 添加多尺度检测支持
# FIXME: 修复内存泄漏问题
# NOTE: 这个函数需要优化性能
```

### 5. 错误处理规范

#### 5.1 异常处理
```python
def load_model(model_path: str) -> torch.nn.Module:
    """加载模型文件
    
    Args:
        model_path: 模型文件路径
        
    Returns:
        加载的模型
        
    Raises:
        FileNotFoundError: 模型文件不存在
        RuntimeError: 模型加载失败
    """
    try:
        if not os.path.exists(model_path):
            raise FileNotFoundError(f"模型文件不存在: {model_path}")
        
        model = torch.load(model_path, map_location='cpu')
        return model
        
    except Exception as e:
        raise RuntimeError(f"模型加载失败: {e}")
```

#### 5.2 日志记录
```python
import logging

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/system.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

def detect_blind_path(image: np.ndarray) -> Dict[str, Any]:
    """检测盲道"""
    logger.info("开始盲道检测")
    
    try:
        result = model.predict(image)
        logger.info(f"检测完成，置信度: {result['confidence']}")
        return result
        
    except Exception as e:
        logger.error(f"检测失败: {e}")
        raise
```

## Android代码规范

### 1. Kotlin代码规范

#### 1.1 命名规范
```kotlin
// 类名使用PascalCase
class MainActivity : AppCompatActivity() {
    // 变量和函数使用camelCase
    private var detectionResult: DetectionResult? = null
    
    // 常量使用UPPER_CASE
    companion object {
        private const val CAMERA_REQUEST_CODE = 1001
        private const val MAX_DETECTION_CONFIDENCE = 0.8f
    }
    
    // 函数命名
    private fun startDetection() {
        // 实现逻辑
    }
    
    private fun onDetectionResult(result: DetectionResult) {
        // 处理检测结果
    }
}
```

#### 1.2 文件结构
```kotlin
package com.blindroad.detector

import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import com.blindroad.detector.databinding.ActivityMainBinding

/**
 * 主活动类
 * 负责相机预览和检测结果显示
 */
class MainActivity : AppCompatActivity() {
    
    private lateinit var binding: ActivityMainBinding
    private var detector: BlindRoadDetector? = null
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // 实现逻辑
    }
    
    private fun initializeDetector() {
        // 初始化检测器
    }
    
    private fun startCamera() {
        // 启动相机
    }
}
```

### 2. 资源文件规范

#### 2.1 布局文件命名
```xml
<!-- 使用snake_case命名 -->
activity_main.xml
fragment_detection.xml
item_detection_result.xml
dialog_settings.xml
```

#### 2.2 字符串资源
```xml
<!-- strings.xml -->
<resources>
    <string name="app_name">盲道检测</string>
    <string name="detection_start">开始检测</string>
    <string name="detection_stop">停止检测</string>
    <string name="obstacle_detected">前方发现障碍物</string>
    <string name="blind_path_detected">检测到盲道</string>
</resources>
```

## 配置文件规范

### 1. JSON配置文件
```json
{
  "system": {
    "name": "盲道检测系统",
    "version": "1.0.0",
    "description": "集成盲道检测、Android应用和语音导航的完整系统"
  },
  "detection": {
    "enabled": true,
    "model_path": "models/yolov8n.pt",
    "confidence_threshold": 0.5,
    "input_size": [640, 640]
  },
  "voice": {
    "enabled": true,
    "language": "zh-CN",
    "voice_speed": 1.0,
    "volume": 0.8
  }
}
```

### 2. YAML配置文件
```yaml
# training_config.yaml
model:
  name: "yolov8n"
  input_size: [640, 640]
  num_classes: 1

training:
  epochs: 100
  batch_size: 16
  learning_rate: 0.01
  optimizer: "adam"

data:
  train_path: "data/train"
  val_path: "data/val"
  test_path: "data/test"
```

## 测试规范

### 1. 单元测试
```python
import unittest
from unittest.mock import Mock, patch
from core.blind_road_sdk import BlindRoadDetector

class TestBlindRoadDetector(unittest.TestCase):
    """盲道检测器测试类"""
    
    def setUp(self):
        """测试前准备"""
        self.detector = BlindRoadDetector()
        self.test_image = np.random.randint(0, 255, (640, 640, 3), dtype=np.uint8)
    
    def test_detection_with_valid_image(self):
        """测试有效图像的检测"""
        result = self.detector.detect(self.test_image)
        
        self.assertIsInstance(result, dict)
        self.assertIn('confidence', result)
        self.assertIn('bbox', result)
    
    def test_detection_with_invalid_image(self):
        """测试无效图像的检测"""
        with self.assertRaises(ValueError):
            self.detector.detect(None)
    
    @patch('cv2.imread')
    def test_load_image_from_file(self, mock_imread):
        """测试从文件加载图像"""
        mock_imread.return_value = self.test_image
        
        result = self.detector.detect_from_file("test.jpg")
        
        self.assertIsNotNone(result)
        mock_imread.assert_called_once_with("test.jpg")
```

### 2. 集成测试
```python
class TestSystemIntegration(unittest.TestCase):
    """系统集成测试"""
    
    def test_full_detection_pipeline(self):
        """测试完整检测流程"""
        # 1. 加载图像
        image = load_test_image()
        
        # 2. 执行检测
        detector = BlindRoadDetector()
        result = detector.detect(image)
        
        # 3. 生成语音指令
        navigator = VoiceNavigator()
        instruction = navigator.generate_navigation_instruction(result)
        
        # 4. 验证结果
        self.assertIsNotNone(instruction)
        self.assertIsInstance(instruction, str)
```

## 版本控制规范

### 1. Git提交信息规范
```bash
# 格式：<类型>(<范围>): <描述>
# 类型：
# feat: 新功能
# fix: 修复bug
# docs: 文档更新
# style: 代码格式调整
# refactor: 代码重构
# test: 测试相关
# chore: 构建过程或辅助工具的变动

# 示例：
git commit -m "feat(detection): 添加多尺度检测支持"
git commit -m "fix(voice): 修复语音识别超时问题"
git commit -m "docs(readme): 更新安装说明"
git commit -m "refactor(android): 重构相机预览逻辑"
```

### 2. 分支命名规范
```bash
# 功能分支
feature/android-ui-enhancement
feature/voice-navigation-system
feature/multi-language-support

# 修复分支
fix/detection-accuracy-issue
fix/voice-synthesis-error

# 发布分支
release/v1.0.0
release/v1.1.0
```

## 性能优化规范

### 1. Python性能优化
```python
# 使用列表推导式
results = [detect(image) for image in images]

# 使用生成器
def process_images(image_paths):
    for path in image_paths:
        yield process_image(path)

# 避免重复计算
class Detector:
    def __init__(self):
        self._model = None
    
    @property
    def model(self):
        if self._model is None:
            self._model = self._load_model()
        return self._model
```

### 2. Android性能优化
```kotlin
// 使用RecyclerView而不是ListView
class DetectionResultAdapter : RecyclerView.Adapter<DetectionResultViewHolder>() {
    // 实现逻辑
}

// 异步处理
class DetectionTask : AsyncTask<Bitmap, Void, DetectionResult>() {
    override fun doInBackground(vararg params: Bitmap): DetectionResult {
        // 后台处理
    }
    
    override fun onPostExecute(result: DetectionResult) {
        // 更新UI
    }
}
```

## 安全规范

### 1. 数据安全
```python
# 敏感信息不要硬编码
import os
from dotenv import load_dotenv

load_dotenv()
API_KEY = os.getenv('API_KEY')

# 输入验证
def validate_image(image: np.ndarray) -> bool:
    """验证输入图像"""
    if image is None:
        return False
    if len(image.shape) != 3:
        return False
    if image.shape[2] != 3:
        return False
    return True
```

### 2. 权限管理
```xml
<!-- AndroidManifest.xml -->
<uses-permission android:name="android.permission.CAMERA" />
<uses-permission android:name="android.permission.RECORD_AUDIO" />
<uses-permission android:name="android.permission.INTERNET" />
```

## 总结

遵循这些代码规范可以确保：

1. **代码一致性** - 团队成员编写的代码风格统一
2. **可维护性** - 代码结构清晰，易于理解和修改
3. **可扩展性** - 良好的架构设计便于功能扩展
4. **质量保证** - 通过测试和代码审查确保代码质量
5. **团队协作** - 规范的开发流程提高团队效率

请所有团队成员严格遵守这些规范，并在代码审查时相互监督。
